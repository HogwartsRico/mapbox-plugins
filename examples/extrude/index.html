<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8' />
    <title>Display voxel world</title>
    <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />
    <script src='../../dist/mapbox-gl.js'></script>
    <link href='../../dist/mapbox-gl.css' rel='stylesheet' />
    <script src="../../dist/bundle.js"></script>
    <style>
        body { margin:0; padding:0; }
        #map { position:absolute; top:0; bottom:0; width:100%; }
        #status {
          position: absolute;
          right: 10px;
          color: rgb(255, 255, 255);
        }
        #canvas {
          border: 1px solid grey;
          position: absolute;
        }
        #color {
          position: absolute;
          left: 5px;
        }
        input[type="color"]  {
            border: 0 solid transparent;
            border-image: url('');
            /* -webkit-appearance:  */
        }
    </style>
</head>
<body>
<div id='map'></div>
<canvas id="canvas" width="400" height="400"></canvas>
<input type="color" id="color">
<h4 id="status">Loading Data..</h4>
<script>
const center = [-87.61694, 41.86625];
mapboxgl.accessToken = false;
var map = new mapboxgl.Map({
    container: 'map',
    style: Mapbox.Config.emptyStyle,
    center: center,
    zoom: 10,
    pitch: 40,
    bearing: 20
});

var voxelGjson = { features: [], type: 'FeatureCollection' };
map.on('load', function() {
    loadHeight(addTerrainLayer);
});

function addTerrainLayer() {
    map.addLayer({
        'id': 'room-extrusion',
        'type': 'fill-extrusion',
        'source': {
            // GeoJSON Data source used in vector tiles, documented at
            // https://gist.github.com/ryanbaumann/a7d970386ce59d11c16278b90dde094d
            'type': 'geojson',
            'data': voxelGjson,
        },
        'paint': {
            // See the Mapbox Style Specification for details on data expressions.
            // https://www.mapbox.com/mapbox-gl-js/style-spec/#expressions

            // Get the fill-extrusion-color from the source 'color' property.
            'fill-extrusion-color': ['get', 'color'],

            // Get fill-extrusion-height from the source 'height' property.
            'fill-extrusion-height': ['get', 'height'],

            // // Get fill-extrusion-base from the source 'base_height' property.
            'fill-extrusion-base': ['get', 'base_height'],

            // Make extrusions slightly opaque for see through indoor walls.
            'fill-extrusion-opacity': 0.7
        }
    });
}

// set z-depth value for vertices in geometry
function attachHeight(geometry, data) {
    // return position vertices in geometry.
    var vertices = geometry.attributes.position.array;
    console.log('bufferGeom Position Array length: '+ vertices.length/3.0);
    for ( var i = 0, j = 0, l = vertices.length; i < l; i ++, j += 3 ) {
        if (!data[i]) {
            break;
        } else {
            // set z-depth value namely height
            vertices[ j-1 ] = data[i] * 0.1;
        }
    }
    console.log('height attach finished...');
    return geometry;
}

const voxelWidth = 0.0005; // real geom distance each voxel width represent.
const startLng = center[0];
const startLat = center[1];
function loadHeight(cb, lodRate) {
    var img = new Image();
    img.onload = function(blob) {
        var canv = document.querySelector('#canvas');
        canv.height = img.height;
        canv.width = img.width;
        var ctx = canv.getContext('2d');
        ctx.drawImage(img, 0, 0);
        var imageData = ctx.getImageData(0, 0, canv.width, canv.width).data;
        
        // image = context.getImageData( 0, 0, width, height );
        console.log('image data length: '+ imageData.length);
        // get the band1 value from height source image.
        for (var i = 0, j = 0, rowNum = 0, colNum = 0; i < imageData.length; j++, i+=4) {
            // i denotes the voxel* bandIndex, j is the voxel index it self.
            // // limit voxel number for performance !
            if (j > 100000) break;
            if (j % Math.round(canv.width) == 0) {
                // console.warn(`current j ${j} represent how many voxel we've traversed, row ${rowNum}, col ${colNum}`);
                rowNum += 1;
                colNum = 0;
            } else {
                colNum += 1;
            }
            // generate voxel feature with height prop.
            voxelGjson.features.push(genVoxelFeature(startLng + colNum*2*voxelWidth, startLat - rowNum*2*voxelWidth, imageData[i]));
        }
        console.warn(`generate terrain from height image completed..`);
        document.querySelector('#status').innerHTML = 'Data loaded, start rendering '
             + canv.height * canv.width + ' voxels';
        if (cb && typeof cb == 'function') {
            cb.apply(this);
        }
        // debugger;
        // // attach height to a virtual geojson geoms
        // attachHeight(bufferPlane, data);
    }
    img.src = './height2.png';
}

function genVoxelFeature(centerX, centerY, height) {
    var voxelColor;
    if (height <= 10) {
        voxelColor = 'rgb(60, 100, 180)'; // blue water
    } else if (height < 60) {
        voxelColor = 'rgb(60, 160, 80)'; // green grass
    } else if (height < 120) {
        voxelColor = 'rgb(60, 200, 80)'; // green grass
    } else if (height < 160) {
        voxelColor = 'rgb(170, 160, 80)'; // land
    } else {
        voxelColor = 'rgb(220, 240, 240)'; // mountain
    }
    return {"type": "Feature",
      "properties": {
        "level": 1,
        "name": "voxel",
        "height": height*10,
        "base_height": 0,
        color: voxelColor
        // "color": `rgb(1, ${height}, ${height})`
      },
      "geometry": {
        "coordinates": [
          [
            [
              centerX-voxelWidth,
              centerY+voxelWidth
            ],
            [
              centerX+voxelWidth,
              centerY+voxelWidth
            ],
            [
              centerX+voxelWidth,
              centerY-voxelWidth
            ],
            [
              centerX-voxelWidth,
              centerY-voxelWidth
            ],
            [
              centerX-voxelWidth,
              centerY+voxelWidth
            ]
          ]
        ],
        "type": "Polygon"
      },
      id: `${centerX}${centerY}${height}`
    };
}

// edit canvas image data by canvas x,y.
function editHeight(x, y, raise=true) {
    const canv = document.querySelector('#canvas');
    const ctx = canv.getContext('2d');
    const imageData = ctx.getImageData(x, y, 1, 1).data;
    if (raise && imageData[0] + 5 <= 255) {
        imageData[0] += 5;
    } else if (!raise && imageData[1] - 5 >=0) {
        imageData[0] -= 5;
    } else {
        return;
    }
    console.warn('changed canvas data..');
    ctx.putImageData(imageData, x, y);
}

</script>

</body>
</html>
